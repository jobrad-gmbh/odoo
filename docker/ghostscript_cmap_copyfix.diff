index 48c9425d1b7fa5783e0bb54a105a884f6dd17590..b59264f6a746e8847de62c6fab1d866ba79c8c39 100644 (file)
--- a/pdf/pdf_cmap.c
+++ b/pdf/pdf_cmap.c
@@ -268,7 +268,7 @@ static int cmap_endfbrange_func(gs_memory_t *mem, pdf_ps_ctx_t *s, byte *buf, by
 {
     pdf_cmap *pdficmap = (pdf_cmap *)s->client_data;
     int ncodemaps, to_pop = pdf_ps_stack_count_to_mark(s, PDF_PS_OBJ_MARK);
-    int i, j;
+    int i, j, k;
     pdfi_cmap_range_map_t *pdfir;
     pdf_ps_stack_object_t *stobj;

@@ -310,78 +310,175 @@ static int cmap_endfbrange_func(gs_memory_t *mem, pdf_ps_ctx_t *s, byte *buf, by
         if (pdf_ps_obj_has_type(&(stobj[i + 2]), PDF_PS_OBJ_ARRAY)
         &&  pdf_ps_obj_has_type(&(stobj[i + 1]), PDF_PS_OBJ_STRING)
         &&  pdf_ps_obj_has_type(&(stobj[i]), PDF_PS_OBJ_STRING)){
-            uint cidbase = stobj[i + 2].val.i;
+            uint cidbase;
             int m, size;

-            if (stobj[i + 2].size < 1 || stobj[i + 2].val.arr[0].type != PDF_PS_OBJ_STRING)
+            if (stobj[i + 2].size < 1)
                 continue;
-            size = stobj[i + 2].val.arr[0].size;

-            cidbase = 0;
-            for (m = 0; m < size; m++) {
-                cidbase |= stobj[i + 2].val.arr[0].val.string[size - m - 1] << (8 * m);
-            }
+            else if (stobj[i + 2].size == 1) {
+                if (stobj[i + 2].val.arr[0].type != PDF_PS_OBJ_STRING)
+                     continue;

-            /* First, find the length of the prefix */
-            for (preflen = 0; preflen < stobj[i].size; preflen++) {
-                if(stobj[i].val.string[preflen] != stobj[i + 1].val.string[preflen]) {
-                    break;
+                size = stobj[i + 2].val.arr[0].size;
+
+                cidbase = 0;
+                for (m = 0; m < size; m++) {
+                    cidbase |= stobj[i + 2].val.arr[0].val.string[size - m - 1] << (8 * m);
                 }
-            }

-            if (preflen == stobj[i].size) {
-                preflen = 1;
-            }
+                /* First, find the length of the prefix */
+                for (preflen = 0; preflen < stobj[i].size; preflen++) {
+                    if(stobj[i].val.string[preflen] != stobj[i + 1].val.string[preflen]) {
+                        break;
+                    }
+                }

-            if (preflen > MAX_CMAP_CODE_SIZE || stobj[i].size - preflen > MAX_CMAP_CODE_SIZE || stobj[i + 1].size - preflen > MAX_CMAP_CODE_SIZE
-                || stobj[i].size - preflen < 0 || stobj[i + 1].size - preflen < 0) {
-                (void)pdf_ps_stack_pop(s, to_pop);
-                return_error(gs_error_syntaxerror);
+                if (preflen == stobj[i].size) {
+                    preflen = 1;
+                }
+
+                if (preflen > MAX_CMAP_CODE_SIZE || stobj[i].size - preflen > MAX_CMAP_CODE_SIZE || stobj[i + 1].size - preflen > MAX_CMAP_CODE_SIZE
+                    || stobj[i].size - preflen < 0 || stobj[i + 1].size - preflen < 0) {
+                    (void)pdf_ps_stack_pop(s, to_pop);
+                    return_error(gs_error_syntaxerror);
+                }
+
+                /* Find how many bytes we need for the cidbase value */
+                /* We always store at least two bytes for the cidbase value */
+                for (valuelen = 16; valuelen < 32 && (cidbase >> valuelen) > 0; valuelen += 1)
+                    DO_NOTHING;
+
+                valuelen = ((valuelen + 7) & ~7) >> 3;
+
+                /* The prefix is already directly in the gx_cmap_lookup_range_t
+                 * We need to store the lower and upper character codes, after lopping the prefix
+                 * off them. The upper and lower codes must be the same number of bytes.
+                 */
+                j = sizeof(pdfi_cmap_range_map_t) + 2 * (stobj[i].size - preflen) + valuelen;
+
+                pdfir = (pdfi_cmap_range_map_t *)gs_alloc_bytes(mem, j, "cmap_endcidrange_func(pdfi_cmap_range_map_t)");
+                if (pdfir != NULL) {
+                    gx_cmap_lookup_range_t *gxr = &pdfir->range;
+                    pdfir->next = NULL;
+                    gxr->num_entries = 1;
+                    gxr->keys.data = (byte *)&(pdfir[1]);
+                    gxr->values.data = gxr->keys.data + 2 * (stobj[i].size - preflen);
+
+                    gxr->cmap = NULL;
+                    gxr->font_index = 0;
+                    gxr->key_is_range = true;
+                    gxr->value_type = CODE_VALUE_CID;
+                    gxr->key_prefix_size = preflen;
+                    gxr->key_size = stobj[i].size - gxr->key_prefix_size;
+                    memcpy(gxr->key_prefix, stobj[i].val.string, gxr->key_prefix_size);
+
+                    memcpy(gxr->keys.data, stobj[i].val.string + gxr->key_prefix_size, stobj[i].size - gxr->key_prefix_size);
+                    memcpy(gxr->keys.data + (stobj[i].size - gxr->key_prefix_size), stobj[i + 1].val.string + gxr->key_prefix_size, stobj[i + 1].size - gxr->key_prefix_size);
+
+                    gxr->keys.size = (stobj[i].size - gxr->key_prefix_size) + (stobj[i + 1].size - gxr->key_prefix_size);
+                    for (j = 0; j < valuelen; j++) {
+                        gxr->values.data[j] = (cidbase >> ((valuelen - 1 - j) * 8)) & 255;
+                    }
+                    gxr->value_size = valuelen; /* I'm not sure.... */
+                    gxr->values.size = valuelen;
+                    if (cmap_insert_map(&pdficmap->cmap_range, pdfir) < 0) break;
+                }
+                else {
+                    (void)pdf_ps_stack_pop(s, to_pop);
+                    return_error(gs_error_VMerror);
+                }
             }
+            else {
+                int m, size, keysize;
+                uint codelo = 0, codehi = 0;

-            /* Find how many bytes we need for the cidbase value */
-            /* We always store at least two bytes for the cidbase value */
-            for (valuelen = 16; valuelen < 32 && (cidbase >> valuelen) > 0; valuelen += 1)
-                DO_NOTHING;
+                size = stobj[i].size;
+                for (m = 0; m < size; m++) {
+                    codelo |= stobj[i].val.string[size - m - 1] << (8 * m);
+                }
+                size = stobj[i + 1].size;
+                for (m = 0; m < size; m++) {
+                    codehi |= stobj[i + 1].val.string[size - m - 1] << (8 * m);
+                }

-            valuelen = ((valuelen + 7) & ~7) >> 3;
+                if (codehi <= codelo || stobj[i + 2].size < (codehi - codelo))
+                    continue;

-            /* The prefix is already directly in the gx_cmap_lookup_range_t
-             * We need to store the lower and upper character codes, after lopping the prefix
-             * off them. The upper and lower codes must be the same number of bytes.
-             */
-            j = sizeof(pdfi_cmap_range_map_t) + 2 * (stobj[i].size - preflen) + valuelen;
+                for (k = codelo; k <= codehi; k++) {
+                    uint cidbase;
+                    int ind = k - codelo;

-            pdfir = (pdfi_cmap_range_map_t *)gs_alloc_bytes(mem, j, "cmap_endcidrange_func(pdfi_cmap_range_map_t)");
-            if (pdfir != NULL) {
-                gx_cmap_lookup_range_t *gxr = &pdfir->range;
-                pdfir->next = NULL;
-                gxr->num_entries = 1;
-                gxr->keys.data = (byte *)&(pdfir[1]);
-                gxr->values.data = gxr->keys.data + 2 * (stobj[i].size - preflen);
+                    if (stobj[i + 2].val.arr[ind].type != PDF_PS_OBJ_STRING)
+                         continue;

-                gxr->cmap = NULL;
-                gxr->font_index = 0;
-                gxr->key_is_range = true;
-                gxr->value_type = CODE_VALUE_CID;
-                gxr->key_prefix_size = preflen;
-                gxr->key_size = stobj[i].size - gxr->key_prefix_size;
-                memcpy(gxr->key_prefix, stobj[i].val.string, gxr->key_prefix_size);
+                    size = stobj[i + 2].val.arr[ind].size;

-                memcpy(gxr->keys.data, stobj[i].val.string + gxr->key_prefix_size, stobj[i].size - gxr->key_prefix_size);
-                memcpy(gxr->keys.data + (stobj[i].size - gxr->key_prefix_size), stobj[i + 1].val.string + gxr->key_prefix_size, stobj[i + 1].size - gxr->key_prefix_size);
+                    cidbase = 0;
+                    for (m = 0; m < size; m++) {
+                        cidbase |= stobj[i + 2].val.arr[ind].val.string[size - m - 1] << (8 * m);
+                    }
+                    /* Find how many bytes we need for the cidbase value */
+                    /* We always store at least two bytes for the cidbase value */
+                    for (valuelen = 16; valuelen < 32 && (cidbase >> valuelen) > 0; valuelen += 1)
+                        DO_NOTHING;
+
+                    valuelen = ((valuelen + 7) & ~7) >> 3;
+
+                    /* Find how many bytes we need for the cidbase value */
+                    /* We always store at least two bytes for the cidbase value */
+                    for (keysize = 16; keysize < 32 && (cidbase >> keysize) > 0; keysize += 1)
+                        DO_NOTHING;
+
+                    keysize = ((keysize + 7) & ~7) >> 3;
+                    if (keysize > MAX_CMAP_CODE_SIZE * 2) {
+                        (void)pdf_ps_stack_pop(s, to_pop);
+                        return_error(gs_error_syntaxerror);
+                    }
+                    preflen = keysize > 4 ? 4 : keysize;
+                    keysize -= preflen;
+
+                    /* The prefix is already directly in the gx_cmap_lookup_range_t
+                     * We need to store the lower and upper character codes, after lopping the prefix
+                     * off them. The upper and lower codes must be the same number of bytes.
+                     */
+                    j = sizeof(pdfi_cmap_range_map_t) + keysize + valuelen;
+
+                    pdfir = (pdfi_cmap_range_map_t *)gs_alloc_bytes(mem, j, "cmap_endcidrange_func(pdfi_cmap_range_map_t)");
+                    if (pdfir != NULL) {
+                        gx_cmap_lookup_range_t *gxr = &pdfir->range;
+                        pdfir->next = NULL;
+                        gxr->num_entries = 1;
+                        gxr->keys.data = (byte *)&(pdfir[1]);
+                        gxr->values.data = gxr->keys.data + keysize;
+
+                        gxr->cmap = NULL;
+                        gxr->font_index = 0;
+                        gxr->key_is_range = false;
+                        gxr->value_type = CODE_VALUE_CID;
+                        gxr->key_prefix_size = preflen;
+                        gxr->key_size = keysize;
+                        for (j = 0; j < preflen; j++) {
+                            gxr->key_prefix[j] = (k >> ((preflen - 1 - j) * 8)) & 255;
+                        }

-                gxr->keys.size = (stobj[i].size - gxr->key_prefix_size) + (stobj[i + 1].size - gxr->key_prefix_size);
-                for (j = 0; j < valuelen; j++) {
-                    gxr->values.data[j] = (cidbase >> ((valuelen - 1 - j) * 8)) & 255;
+                        for (j = preflen; j < preflen + keysize; j++) {
+                            gxr->keys.data[j] = (k >> (((preflen + keysize) - 1 - j) * 8)) & 255;
+                        }
+
+                        gxr->keys.size = keysize;
+                        for (j = 0; j < valuelen; j++) {
+                            gxr->values.data[j] = (cidbase >> ((valuelen - 1 - j) * 8)) & 255;
+                        }
+                        gxr->value_size = valuelen; /* I'm not sure.... */
+                        gxr->values.size = valuelen;
+                        if (cmap_insert_map(&pdficmap->cmap_range, pdfir) < 0) break;
+                    }
+                    else {
+                        (void)pdf_ps_stack_pop(s, to_pop);
+                        return_error(gs_error_VMerror);
+                    }
                 }
-                gxr->value_size = valuelen; /* I'm not sure.... */
-                gxr->values.size = valuelen;
-                if (cmap_insert_map(&pdficmap->cmap_range, pdfir) < 0) break;
-            }
-            else {
-                (void)pdf_ps_stack_pop(s, to_pop);
-                return_error(gs_error_VMerror);
             }
         }
     }
